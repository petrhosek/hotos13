\section{Overview}
\label{sec:overview}

\begin{structure}
  \item What is NaCl and how does it work?
  \item NaCl architecture and components (with figure)
  \item Process support issues (\eg no fork on Windows)
  \item Proposed approach with process service
  \item Memory sharing between processes
  \item Memory service design
\end{structure}

%we need to talk about files as a service -- naturally comes up in the
%microkernel structure stuff -- and how file service handles namespaces
%but file I/O is essentially native

%and we rely on the underlying OS to do the heavy lifting. but the
%positioning sounds right.

Native Client, commonly abbreviated ``NaCl'' when used as an adjective,
is an open-source production-quality SFI-based sandbox for the safe
execution of untrusted, multi-threaded user-level machine
code~\cite{yee:ieee-sp09,sehr:usenix-sec10,ansel:pldi11}. While
primarily aimed towards executing native compiled code inside the web
browser, the NaCl core components can be also used as a
general-purpose sandbox.

The goal is to provide full POSIX interface. While Native Client already
provides a subset of POSIX API including thread interface and common
file I/O interfaces, it still misses important parts such as process
support, user management or non-blocking I/O. We believe that it is
possible to implement the missing functionality using microkernel design
to provide fast yet portable and safe alternative to the existing VM
implementations.

\begin{figure}
\centering
%\includegraphics{architecture}
\caption{Overview of core NaCl components}
\label{fig:architecture}
\end{figure}

The NaCl architecture, depicted in Figure~\ref{fig:architecture},
comprises of many different components resembling different components
of an operating system. The component which fulfills the role of kernel
is the \emph{service runtime}.
% largely resembles existing monolithic and micro-kernel design.

The NaCl architecture resembles existing micro and hybrid kernels.
However, compared to on-the-metal microkernels, there are number of
significant differences. First of all, Native Client sits on top of an
existing monolithic kernel (\ie Linux, OS X or Windows), so the various
microkernel-related overheads (\eg context switch) still exist.

\todo{Explain how the NaCl architecture compares with on-the-metal
  micro-kernel designs, viz: Native Client is on top of an existing
  monolithic kernel, so the various microkernel-related overheads
  (context switch, etc) still exist.  The benefits are structural:
  easier replacement of components/modules, easier security audits.}



Native Client follows microkernel design by implementing many aspects
of the sandbox in terms of services. All services are implemented using
SRPC (Simple RPC), a simple and basic remote method invocation
mechanism supporting only basic data types (int, float, char) in
addition to arrays and internal descriptors. SRPC is implemented
entirely in untrusted code on top the IMC (Inter-Module Communications),
Native Client's reliable datagram service. External data representation
strategies can easily be layered on top of SRPC.

%Native Client follows micro-kernel design by implementing many aspects
%of the sandbox in terms of services. All services are implemented using
%SRPC (Simple RPC) which \ldots implemented on top of the IMC
%(Inter-Module Communications). SRPC abstraction is implemented entirely
%in untrusted code. SRPC provides a convenient syntax for declaring
%procedural interfaces between NaCl modules, supporting a few basic types
%(int, float, char) as well as arrays in addition to NaCl descriptors.
%More complex types and pointers are not supported. External data
%representation strategies can easily be layered on top of SRPC.

\subsection{Service Runtime}

The service runtime is a native executable which provides resource
abstractions to isolate NaCl applications from host resources and
underlying operating system interfaces. Even though it shares a process
with the contained NaCl module, the service runtime prevents untrusted
code from inappropriate accesses using a combination of various
techniques. % which differ for various target architectures. The service
% runtime trusted code and data are only accessible through a controlled
% interface.

The service runtime functionality is only accessible through system
calls which resemble standard kernel system calls by performing a contex
switch from untrusted to trusted code, even though they use different
hardware mechanism~\cite{yee:ieee-sp09,sehr:usenix-sec10}. The service
runtime Application Binary Interface (ABI) exposed to the untrusted code
is modeled after POSIX ABI and includes subset of the POSIX thread
interface as well as common POSIX file I/O interfaces. This makes it
easy to port existing POSIX application over to Native Client with
minimal or no changes at all.

%While Native Client already resembles existing hybrid kernel design
%providing facilities such as multi-threading and
%virtual memory management, it lacks two important features, process
%management and shared memory. \todo{Not sure whether shared memory
%really that important?}

\subsection{Reverse Service}

% While service runtime is the in-process sandbox enforcing fault
% isolation and providing facilities such basic IPC (SRPC),
% virtual memory, resource abstraction or the system call interface, it is
% the \emph{reverse service} which provides inter-process services such as
% file access, application IPC or process support.

The \emph{reverse service} represents the embedding interface, providing
core facilities such as process management, file system access or
application. IPC % thereby resembling the traditional micro-kernels. 
The name comes from the fact that unlike other service which act as a
server, the reverse service starts as a client connecting to a service
runtime which acts a server and only then is the connection
\emph{reversed} and reverse service becomes the server. This setup is
necessary since service runtime is not allowed to establish outside
connection as one of the security measures.

Each service runtime instance has a connection to reverse service. The
\emph{initial} service runtime has a connection to the trusted reverse
service \ldots while child processes might be using a different instance
of the reverse service. This allows \ldots injecting a proxy which
intercepts some (or all) calls to the actual reverse service or provide
entirely different reverse service implementation running in untrusted
code.

\subsection{Integrated Runtime}

Integrated Runtime (IRT) is an untrusted library providing a stable,
backward compatible interface to NaCl module. IRT ensures that once
compiled, NaCl module will run forever even with a newer version of NaCl
runtime. Application programmers do not typically use IRT directly,
instead they use one of the provided C libraries (Newlib or Glibc) which
hide away internal details and provide common interface.

Facilities provided to untrusted code may be implemented either as NaCl
systeem calls or as SRPC services. IRT abstracts these differences and
provides unified interface. The advantage of using services over system
calls is extensibility and easier development, the disadvantage is
primarily performance overhead as each service method invocation
requires several system calls (\ie sequence of \lstinline`sendmsg`
/\lstinline`recvmsg` invocations).

\todo{Describe the role of IRT. Describe name and kernel services, their
role.}
