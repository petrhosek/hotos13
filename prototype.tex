\section{Prototype of the Embedding Interface}
\label{sec:prototype}

%Although Native Client already provides a subset of POSIX interface,
%which allows porting some of the existing POSIX based code, it is still
%missing certain interfaces which makes it difficult to run existing
%applications simply by recompiling them using NaCl tool chain.

%Rather than implementing the missing interfaces as a part of service
%runtime unnecessarily increasing the TCB size, we believe that it is
%possible to implement the missing POSIX interfaces using the microkernel
%design by implementing the majority of functionality in the untrusted
%code to provide a fast yet portable and secure alternative to the
%existing VM implementations.

%While service runtime is the in-process sandbox enforcing fault
%isolation and providing facilities such as network communication, memory
%management, resource abstraction or the system call interface, it is the
%\emph{reverse service} which provides inter-process services such as
%file access, process support or IPC facilities.

%Following the Liedtke's~\cite{liedtke:sosp93} minimality principle, the
%service runtime should provide only the core functionality:
%\begin{itemize}
%\item managing the address space, in particular the memory protection to
	%ensure that all data accesses are properly sandboxed; 
%\item threads as an abstraction for allocating CPU;
%\item IPC mechanism necessary to invoke remote services, in Native
	%Client realized through internal descriptors.
%\end{itemize}

In this section, we describe a design of embedding interface, in
particular services to allow support for process creation and control,
file and directory operations.  All services are implemented using SRPC.
This mechanism only support basic data types (\ie \lstinline`int`,
\lstinline`float`, \lstinline`char`) in addition to arrays and internal
descriptors. These are being used (mostly) as capabilities. For
efficiency, the operations on descriptors are implemented as NaCl system
calls.

%While the operations on descriptors are implemented as NaCl system calls
%for efficiency, the majority of interfaces provided to untrusted should
%be implemented in terms of IPC as SRPC services. IRT allows us to
%abstract these differences and provides unified interface. The
%advantage of using services over system calls is extensibility and
%easier development, the disadvantage is primarily performance overhead
%as each service method invocation requires several system calls (\ie
%sequence of \lstinline`sendmsg`/\lstinline`recvmsg` invocations).

%The features we want to provide are flexibility and maintainability.
%\ldots embedding interface \ldots allows to use \ldots in various setups
%\ie executing native code within a web page, lightweight virtualization
%in cloud provisioning

%Different implementations of embedding interface, one for browser, one
%for server, one for mobile phone, etc.

\begin{figure}
\centering
%\includegraphics{architecture}
\caption{Embedding interface architecture}
\label{fig:architecture}
\end{figure}

The embedding interface runs as a process separate of the service
runtime instance with each service running in its own thread (or
process), which improves the robustness and security of the system. When
started, service runtime is identified by the socket address which is
used to establish the \emph{command channel}. This channel is used to
control the runtime execution, in particular to load the NaCl executable
and IRT into memory, to establish the reverse channel, to start and stop
the process execution.  The \emph{reverse channel} is used by the
service runtime to access the embedding interface. The process holding
the command channel can be seen as an effective process parent. While it
is indeed possible to have multiple command channels, there has to be at
least one channel at any given point.  When the last command channel is
disconnected, the service runtime immediately terminates the execution.

%Each service runtime instance has a connection to reverse service. The
%\emph{initial} service runtime has a connection to the trusted reverse
%service \ldots while child processes might be using a different instance
%of the reverse service. This allows \ldots injecting a proxy which
%intercepts some (or all) calls to the actual reverse service or provide
%entirely different reverse service implementation running in untrusted
%code.

%The \emph{reverse service} represents the embedding interface, providing
%core facilities such as process management, file system access or
%application. IPC % thereby resembling the traditional micro-kernels.
%The name comes from the fact that unlike other service which act as a
%server, the reverse service starts as a client connecting to a service
%runtime which acts a server and only then is the connection
%\emph{reversed} and reverse service becomes the server. This setup is
%necessary since service runtime is not allowed to establish outside
%connection as one of the security measures.

\subsection{Process Support}
\label{sub:process_support}

The support for process creation and control is a part of the POSIX.1,
Core Services standard, being used by a large number of applications.
The most important requirement imposed on process support is
portability. Since the NaCl executable must run on any supported
platform without recompilation  the process support can only rely on a
common denominator of the functionality provided by the supported
underlying operating systems (\ie Windows, Linux and OS X). The POSIX
specification defines two interfaces for creating new processes,
\lstinline`fork` and \lstinline`posix_spawn`. While the former creates a
copy of an existing process, the latter creates a new process from the
specified image.  However, different operating systems implement
different subset of these primitives. Linux only provides
\lstinline`fork` (or \lstinline`clone` as a non-standard extension).
Windows \lstinline`CreateProcess` is equivalent to POSIX
\lstinline`posix_spawn`. Only OS X provides both primitives.

The process support must have a clear semantics, which may be an issue
with \lstinline`fork` which is supposed to create the exact copy the
existing process. However, when using a \lstinline`fork` with a
multi-threaded program, we might end up in an inconsistent state since
only the thread invoking \lstinline`fork` is cloned.  This problem is
magnified in case of the service runtime which shares the process with
the untrusted code and uses automatic resource management to increase
the reliability of resource (de)allocation. If we use the
\lstinline`fork` system call to create a copy of the existing process,
the bookkeeping information will become invalid (\eg memory mappings,
descriptors, locks) leading to potentially inconsistent state.
%if \lstinline`pthread_atfork` is not used everywhere that it is needed.

%Therefore, following the same philosophy, our main goal when designing
%the process support for NaCl was to provide an equivalent of the POSIX
%\lstinline`fork` system call. However, there are two challenges.

To implement the process support, the embedding interface must provide a
\emph{process service} with a set of methods which may be used to spawn
a new instance of service runtime returning the socket address. Since
these methods are accessible to applications, we can rely on untrusted
libraries (\ie IRT) to implement whatever semantics is needed on top
these primitives. Once the new service runtime has been created, the
invoking process can decide whether it will establish the command
channel and become the parent, or whether it will pass the socket
address to another process.  This allows creating arbitrary process
hierarchy.  While the standard IRT implementation is expected to emulate
the standard POSIX behavior, embedders may provide a custom IRT
implementations which will use a different strategy.

The parent process is responsible for loading the executable image and
IRT over the command channel and subsequently starting the execution.
This allows implementation of the \lstinline`posix_spawn` function
entirely in the untrusted code. To implement \lstinline`fork`, we need a
way to share memory between processes, further discussed in the next
section.  Since the parent process is responsible for setting up the
reverse channel connection, it can either pass the socket up to the
embedded interface, which will likely be the default behavior, or it can
subsume the role of embedding interface itself. This allows the parent
to either proxy some of the services or completely replace them. Such
strategy could be used to further restrict the child process privileges,
\eg for executing computation kernels with restricted filesystem access
emulating chroot-like behavior entirely in the untrusted code.

\subsection{Backing Store}
\label{sub:backing_store}

\todo{We may decide to implement this with regular files, for example,
which can be \lstinline`MAP_SHARED` by the untrusted library.}

When the process spawns a new subprocess using the \lstinline`fork`
operation, the child's address space should be an exact copy of its
parent's.  The inefficient way to implement such behavior would be to
copy the content of parent's address space. The efficient way, typically
used by OS kernels, is to use the copy-on-write mechanism.  To allow
implementation of the \lstinline`fork`-like emulation using the
copy-on-write semantics, the embedding interface has to provide the
\emph{backing store}. When used, all the process memory will be backed
by a shared memory, thought initially not necessarily shared.

When a new subprocess is created, it receives the shared memory
descriptors together with the location in the parent's process address
space. Both parent and child processes have to change page protection of
all memory pages to read-only to emulate copy-on-write, which is a
responsibility of IRT. On fault, the affected page will be copied to a
new shared memory which belongs to the subprocess, the reference count
to the old page within the original shared memory object is decremented,
the new shared memory pages are mapped in place of the original pages
with write permissions, and the affected thread is continued.

The backing store will be responsible for managing the shared memory,
in particular (de)allocating the shared memory and automatic reference
management. This is necessary since shared memory is potentially a
scarce resource. There is also a space for optimizations. First, we do
not want a separate shared memory file for every page (\eg limit on
number of file descriptors, filesystem-related overhead), but if the
shared memory object is multiple pages in size and a ``hole'' in the
middle has zero references, we need to find a way to reclaim the space.
Second, we have to make sure that the memory management is safe with
respect to threads. This is not an issue on systems where altering the
existing mapping can be done atomically, in particular on Linux and OS X
(\ie mmap on top of existing mapping).  However, on Windows where memory
has to be unmapped first and therefore over-mapping is not atomic, we
have to stop all threads while memory pages are being manipulated.

%User-level fork emulation library manages address space.  All memory
%are backed by shared memory, though initially not necessarily actually
%shared.  On fork, new subprocess is created which have special IRT
%that speaks the fork-emulation protocol.  The subprocess receives
%shared memory descriptors and location where they are mapped in the
%parent process.  Both parent and child processes change page
%protection of all pages to read-only to emulate copy-on-write.  On
%fault, affected page is copied to new shared memory, reference count
%to the old page within the original shared memory object is
%decremented, the new shared memory pages mapped in place with writable
%mapping, and the affect thread is continued.  We don't want to have a
%separate shared memory file for every 64KB page (probably too many
%descriptors, filesystem related overhead), so there will be some
%interesting optimizations here: if we shared memory object is multiple
%pages in size, but a ``hole'' in the middle has zero references, how
%do we reclaim the disk / paging space?

%Concerns: shared memory is a scarce resource.  /dev/shm is typically a
%small fraction of RAM size.  Threads vs fork -- may need to stop all
%other threads while pages are being manipulated?  On Unices where mmap
%on top of existing mapping is atomic, it may not be necessary; on
%Windows where unmap must occur first and therefore overmapping is not
%atomic, this is likely to be necessary.

\subsection{File Service}
\label{sub:file_service}

\todo{Talk about file service as a way to expose host's (or other
machine's) filesystem.}

\subsection{Network Service}
\label{sub:network_service}

\todo{Accessing the network interface, in particular to binding to
sockets and accepting incoming connections.}
